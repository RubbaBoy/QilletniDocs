{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Qilletni","text":"<p>Qilletni is a powerful Domain Specific Language for all things music. Seamlessly link streaming services and statistics platforms to curate playlists, find new music, automate playing, and integrate with external tools and APIs with its flexible syntax and library set.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Platform Integration: Import packages to gain access to different music platforms, such as spotify and lastfm</li> <li>Platform-Agnostic Types: Songs, artists, albums, etc. are automatically converted between music platforms for seamless use</li> <li>Weight-Based Music Selection: Use weighted collections for advanced playlist orchestration</li> <li>Native Java Bindings: Leverage Java libraries for enhanced functionality as if they were written in Qilletni</li> <li>Package Support: Create your own reusable package with our package manager, or leverage existing packages such as http, json, postgres, or metadata</li> </ul> <p>Get Started \u2192</p>"},{"location":"#get-started","title":"Get Started","text":"<p>Jump right into Qilletni with our Getting Started Guide, where you\u2019ll learn how to:</p> <ul> <li>Install Qilletni.</li> <li>Write your first program.</li> <li>Run <code>.ql</code> scripts to create and manage playlists.</li> </ul> <pre><code>// Weight the songs in your playlist\nweights myWeights =\n    | 20% \"Song A\" by \"Artist A\"  // 20% of the time, play \"Song A\"\n    | 10% \"Song B\" by \"Artist B\"\n    | 5x  \"Song C\" by \"Artist C\"  // Play \"Song C\" 5 times more often\n\n// Get your playlist &amp; assign weights to it\ncollection myCollection = \"My Playlist\" collection by \"username\" weights[myWeights]\n\n// Play 10 songs from your playlist\nplay myCollection limit[10]\n</code></pre> <p>Start Now \u2192</p>"},{"location":"#reference-documentation","title":"Reference Documentation","text":"<p>Dive deep into the Qilletni language and its libraries:</p> <ul> <li>Language Reference: Syntax, entities, functions, and control flow.</li> <li>Library Reference: Qilletni documentation for all official packages</li> <li>Java API Reference: Documentation for all API methods provided by Qilletni to make your own service providers packages with native bindings</li> </ul>"},{"location":"#why-qilletni","title":"Why Qilletni?","text":"<p>Working with any music service API is largely boilerplate, moving your focus away from what you're making to how to make it. Qilletni provides a familiar C-style syntax with its own music-specific features to speed up the process of creation.</p> <p>It's never been this easy to programmatically transfer songs or playlist from one music service to another, or manipulate how playlists are played.</p>"},{"location":"#example-program","title":"Example Program","text":"<p>Here\u2019s a sneak peek of what Qilletni can do:</p> <p>The following program takes a Spotify playlist, plays 2 songs from it, and then 3 recommended songs with high energy and low popularity. All songs are added to a new playlist on your account.</p> <pre><code>import \"spotify:recommendations.ql\"\nimport \"spotify:play_redirect.ql\"\nimport \"spotify:playlist_tools.ql\"\nimport \"std:types/collections/stack.ql\"\n\n// Songs to play more frequently\nweights powerRotation =\n    | 85% [\"Wants I Need\" by \"156/Silence\",\n            \"Anti-Saviour\" by \"Voluntary Victim\",\n            \"Millstone\" by \"ROSARY\"]\n    | 15% [\"Heavy Rain\" by \"Konami Kode\",\n            \"Decay\" by \"Elwood Stray\",\n            \"All or Nothing\" by \"Foundations\"]\n\n// 30% of the time, choose from powerRotation\nweights myWeights =\n   |~ 30% powerRotation\n\n// A spotify playlist to play songs from, with weights\ncollection mySongs = \"My Playlist #59\" collection by \"rubbaboy\" weights[myWeights]\n\n// Redirect the \"play\" keyword to add played songs to a list, instead of playing them\nsong[] songList = []\nredirectPlayToList(songList)\n\n// Recommend Spotify songs\nRecommender recommender = new Recommender()\n        ..seedTracks = [\"Truth Serum\" by \"Gutter King\", \n                        \"Wayside\" by \"AEONS\"]\n        ..targetEnergy = 1.0     // High energy\n        ..targetPopularity = 10  // Low popularity\n\n// Recommend 30 songs, add them to a stack\nsong[] recs = recommender.recommend(30)\nStack recommendations = Stack.fromList(recs)\n\n// Play 2 shuffled songs from mySongs playlist, then 3 recommendations\nfor (recommendations.size() &gt;= 3) {\n    play mySongs limit[2]\n\n    for (i..3) {\n        play recommendations.pop()\n    }\n}\n\n// Create a new playlist in Spotify\nDate date = Date.now()\ncollection myNewPlaylist = createPlaylist(\"Qilletni generated on %d/%d\".format([date.getMonth(), date.getDay()]))\n\n// Add the songs to the new playlist\naddToPlaylist(myNewPlaylist, songList)\nprintf(\"Created a playlist with %s songs\", [songList.size()])\n</code></pre> <p>Explore more examples in our Examples Section \u2192</p>"},{"location":"examples/","title":"Code Examples","text":""},{"location":"examples/#adding-metadata-tags","title":"Adding Metadata Tags","text":"<p>The following uses the metadata library. This attaches data to songs, albums and artists to help filter or organize music. This uses an internal database, so metadata persists.</p> <pre><code>import \"metadata:metadata.ql\"\n\nMetadata metadata = Metadata.createMetadata(Database.createDatabase(\"localhost\", 5444, \"metadata\", \"admin\", \"pass\"))\n\nsong mySong = \"God Knows\" by \"Knocked Loose\"\n\nmetadata.addTag(mySong, \"goated\")\nmetadata.addTag(mySong, \"cool\")\n\nprintf(\"Tags for song: %s\", [metadata.getTags(mySong).join(\", \")])  // Prints \"Tags for song: goated, cool\"\n</code></pre>"},{"location":"examples/#lastfm-to-spotify-conversion","title":"Last.Fm to Spotify Conversion","text":"<p>As Qilletni supports automatic and efficient conversion between music providers, collections from one to another is seamless. The following takes a list of Last.Fm songs and adds them to a newly created Spotify playlist.</p> <pre><code>import \"lastfm:lastfm.ql\"\nimport \"spotify:playlist_tools.ql\"\n\nprovider \"lastfm\" // (1)!\n\nPage page = new Page()\n                ..page = 1\n                ..count = 100\n\nLastFmResult result = getTopTracks(\"RubbaBoy\", \"3month\", page) // (2)!\n\nif (result.isError()) { // (3)!\n    printf(\"Error: %s\", [result.errorMessage])\n    exit(1)\n}\n\nfor (track : result.wrappedData.getValue()) {\n    printf(\"%s\\t plays  %s\", [track.playCount, track.track])\n}\n\nprovider \"spotify\" // (5)!\n\ncollection newPlaylist = createPlaylist(\"Top Song Playlist\") // (4)!\naddToPlaylist(newPlaylist, result.data)\n\nprint(\"Created a playlist with %s songs\".format([result.data.size()]))\n</code></pre> <ol> <li>Ensures the music provider is Last.Fm</li> <li>Makes an API request to Last.Fm to get the top 100 songs played in the last 3 months</li> <li>Methods that are API calls are handled a little more manually, so they should gracefully terminate if unsuccessful</li> <li>Create a new Spotify playlist and add the songs</li> <li>Switch the music provider to Spotify so conversion happens when needed</li> </ol>"},{"location":"examples/#spotify-recommendation-api","title":"Spotify Recommendation API","text":"<p>The Spotify library's Recommender entity, the full Spotify recommendation system can be utilized to fine tune music selections.</p> <pre><code>import \"spotify:recommendations.ql\"\nimport \"spotify:play_redirect.ql\"\nimport \"spotify:playlist_tools.ql\"\nimport \"std:types/collections/stack.ql\"\n\nweights powerRotation =\n    | 85% [\"Wants I Need\" by \"156/Silence\", \"Monarch\" by \"Glasswaves\",\n            \"Anti-Saviour\" by \"Voluntary Victim\",\n            \"Millstone\" by \"ROSARY\",\n            \"Hell (I let the Devil In)\" by \"Breakwaters\",\n            \"Distance\" by \"Sleep Waker\",\n            \"Claustrophobic\" by \"Before I Turn\"]\n    | 15% [\"Heavy Rain\" by \"Konami Kode\",\n            \"Decay\" by \"Elwood Stray\",\n            \"All or Nothing\" by \"Foundations\"]\n\nweights metalWeights =\n   |~ 30% powerRotation\n\ncollection metalSongs = \"My Playlist #59\" collection by \"rubbaboy\" weights[metalWeights]\n\nsong[] songList = []\nredirectPlayToList(songList)\n\n// All recommended songs\nStack recommendations = new Stack()\n\nfun generateUniqueRecommendations() {\n    Recommender recommender = new Recommender()\n            ..seedTracks = [\"Truth Serum\" by \"Gutter King\", \n                            \"Paradise\" by \"Dark Island\",\n                            \"Anti-Saviour\" by \"Voluntary Victim\",\n                            \"Spiral\" by \"Feyn Entity\",\n                            \"Dark Tunnel\" by \"Beholder\"]\n            ..targetEnergy = 1.0\n            ..targetPopularity = 10\n\n    song[] recs = recommender.recommend(100)\n\n    for (rec : recs) {\n        if (!metalSongs.containsArtist(rec.getArtist())) {\n            recommendations.push(rec)\n        }\n    }\n\n    print(\"Generated %d unique recommendations\".format([recommendations.size()]))\n}\n\ngenerateUniqueRecommendations()\n\n// Play 2 shuffled songs from metal playlist, then 3 recommendations\nfor (recommendations.size() &gt;= 3) {\n    play metalSongs limit[2]\n\n    for (i..3) {\n        play recommendations.pop()\n    }\n}\n\n// Add all played songs to a new playlist\nDate date = Date.now()\ncollection myPlaylist = createPlaylist(\"Recs only %d/%d\".format([date.getMonth(), date.getDay()]))\n\naddToPlaylist(myPlaylist, songList)\nprint(\"Created a playlist with %s songs\".format([songList.size()]))\n</code></pre>"},{"location":"examples/#listening-for-song-playing","title":"Listening For Song Playing","text":"<p>Qilletni can also use hooks to monitor things like what song is currently being played. This ability also allows for server-side processing. The below example logs when the user changes what song they are playing on their account. For how this is implemented, see the Background Tasks page.</p> <pre><code>import \"spotify:hooks.ql\"\n\nfun songPlayCallback(sng) { // (1)!\n    printf(\"Playing:\\t%s - %s\", [sng.getTitle(), sng.getArtist().getName()])\n}\n\nonSongPlay(songPlayCallback)\n\n// Halt program forever, running background tasks\nprocessBackground()\n</code></pre> <ol> <li>This method is invoked every time a song is changed</li> </ol>"},{"location":"package_configs/","title":"Package Configs","text":"<p>Qilletni offers the ability for libraries and the internal system to store persistent, user-editable key value strings. This is useful for authentication, program settings, etc.</p> <p>The <code>qilletni persist</code> command is used to manage this data from the command line. The format is:</p> <pre><code>qilletni persist &lt;libraryName&gt;  [-ar] [&lt;data&gt;...]\n</code></pre> <p>The package name may either be <code>internal</code>, for the Qilletni system itself, or an actual package name, such as <code>spotify</code> or <code>lastfm</code>. To view all properties of a library, use the <code>--all</code> or <code>-a</code> flag, such as:</p> <pre><code>$ qilletni persist internal --all\n| Property       | Value |\n| -------------- | ----- |\n| eagerMusicLoad | true  |\n</code></pre> <p>To remove a value, use the <code>--remove</code> or <code>-r</code> flag, such as:</p> <pre><code>$ qilletni persist internal -r eagerMusicLoad\nRemoving: eagerMusicLoad\n</code></pre> <p>To set a value, simply do <code>key=value</code>. This may be done multiple times in the same command.</p> <pre><code>$ qilletni persist internal eagerMusicLoad=true foo=bar\nParameter 'eagerMusicLoad' set to 'true' in package 'internal'.\nParameter 'foo' set to 'bar' in package 'internal'.\n\n$ qilletni persist internal --all\n| Property       | Value |\n| -------------- | ----- |\n| foo            | bar   |\n| eagerMusicLoad | true  |\n</code></pre> <p>Viewing specific values is done by just putting in the key name, without an <code>=</code> after. There may be multiple, and also mixed with setting values. If mixed with setting values, the values being viewed will be printed first, and then set.</p> <pre><code>$ qilletni persist internal eagerMusicLoad\n| Property       | Value |\n| -------------- | ----- |\n| eagerMusicLoad | true  |\n</code></pre>"},{"location":"package_configs/#using-in-native-libraries","title":"Using In Native Libraries","text":"<p>In a native library, from Java, package configs can be used via a native injected class, injecting the PackageConfig class, as shown below.</p> <pre><code>public class MyLibraryFunctions {\n    private final PackageConfig packageConfig;\n\n    public MyLibraryFunctions(PackageConfig packageConfig) {\n        this.packageConfig = packageConfig;\n    }\n}\n</code></pre> <p>To use this, the package config may be accessed via get(String) and set(String, String). More methods are outlined in the javadocs. To save the config, you must use the saveConfig() method.</p>"},{"location":"package_configs/#using-in-qilletni-code","title":"Using In Qilletni Code","text":"<p>Currently, package configs are only supported at the native level. To get a interact with data, a native method can be made to access or write to it.</p>"},{"location":"project_structure/","title":"Project Structure","text":"<p>Explore the types of projects, and how to organize files</p>"},{"location":"project_structure/#types-of-projects","title":"Types of Projects","text":"<p>With the Qilletni command, you can initialize two types of projects: an application and a library. An application is a standalone project that can be run, while a library is designed to be packaged and imported into other projects.</p> <p>A library may also be ran as an application is, but it is not the primary use case.</p> <p>To create the different types of projects, the following option in the qilletni command is used:</p> <pre><code>qilletni init -t &lt;type&gt;\n</code></pre> <p>Where <code>&lt;type&gt;</code> is either <code>application</code> or <code>library</code>. By default, it is set to <code>application</code>.</p> <p>Below are the structure and differences of each type of project. The first two sections will cover projects without native bindings, while the last section will cover projects with native bindings.</p>"},{"location":"project_structure/#applications","title":"Applications","text":"<p>To create an application, navigate to your desired directory and run the following command:</p> <pre><code>qilletni init &lt;project_name&gt;\n</code></pre> <p>The resulting project structure will be as follows:</p> <pre><code>project_name/\n\u2514\u2500\u2500 qilletni-src/\n    \u251c\u2500\u2500 project_name.ql\n    \u2514\u2500\u2500 qilletni_info.yml\n</code></pre> <p>Where <code>project_name.ql</code> is the initial source file for the project. All source files should be added to <code>qilletni-src/</code>.</p>"},{"location":"project_structure/#libraries","title":"Libraries","text":"<p>To create a library, navigate to your desired directory and run the following command:</p> <pre><code>qilletni init -t library &lt;project_name&gt;\n</code></pre> <p>The resulting project structure will be as follows:</p> <pre><code>project_name/\n\u251c\u2500\u2500 examples\n\u2502   \u2514\u2500\u2500 example1.ql\n\u2514\u2500\u2500 qilletni-src/\n    \u251c\u2500\u2500 project_name.ql\n    \u2514\u2500\u2500 qilletni_info.yml\n</code></pre> <p>In the example project, <code>example.ql</code> is an application file that uses the current library. Its contents will look something like:</p> <pre><code>import \"project_name:project_name.ql\"\n\n// Say hello from the sample function\nsayHello()\n</code></pre> <p>This file is not actually part of the project, so it is not included in the <code>qilletni-src/</code> directory. Examples of a library are conventionally stored in this directory, or its subdirectories</p> <p>The example source file for this will contain:</p> <pre><code>fun sayHello() {\n    print(\"Hello, World!\")\n}\n</code></pre> <p>Which defines a simple method an application importing it may use.</p>"},{"location":"project_structure/#project-with-native-bindings","title":"Project With Native Bindings","text":"<p>A project with native bindings is a project that has Java code bound to Qilletni native methods. To create a project with native bindings, use the <code>--native-class</code> option in the <code>qilletni init</code> command:</p> <pre><code>qilletni init --native-class com.example.qilletni.ProjectName &lt;project_name&gt;\n</code></pre> <p>The given class name is the class to initially create a project with. This may be changed or removed later. The resulting structure looks like:</p> <pre><code>project_name\n\u251c\u2500\u2500 build.gradle\n\u251c\u2500\u2500 gradle.bat\n\u251c\u2500\u2500 gradlew\n\u251c\u2500\u2500 settings.gradle\n\u251c\u2500\u2500 gradle\n\u2502   \u2514\u2500\u2500 wrapper\n\u2502       \u251c\u2500\u2500 gradle-wrapper.jar\n\u2502       \u2514\u2500\u2500 gradle-wrapper.properties\n\u251c\u2500\u2500 qilletni-src\n\u2502   \u251c\u2500\u2500 project_name.ql\n\u2502   \u2514\u2500\u2500 qilletni_info.yml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 main\n        \u2514\u2500\u2500 java\n            \u2514\u2500\u2500 com\n                \u2514\u2500\u2500 example\n                    \u2514\u2500\u2500 ProjectName.java\n</code></pre> <p>A Qilletni project with native bindings uses the Gradle build system to compile the project. The <code>ProjectName.java</code> file is the initial native binding class, and more Java source files may be added in <code>src/main/java</code>.</p>"},{"location":"project_structure/#file-types","title":"File Types","text":"<p>Qilletni includes several different kind of files that can be used in a project. Below are the types of files and their purposes.</p>"},{"location":"project_structure/#source-files-ql","title":"Source Files <code>.ql</code>","text":"<p>A .ql` file is a Qilletni source file. It contains the code that will be interpreted by the Qilletni runtime. They may import other source files, or stay standalone.</p>"},{"location":"project_structure/#qilletni_infoyml","title":"<code>qilletni_info.yml</code>","text":"<p>The <code>qilletni_info.yml</code> file is a configuration file for the project. It contains metadata about the project, with available properties outlined below. It is used by the Qilletni runtime to display information about the project. When a library is packaged, it is parsed into a <code>qll.info</code> file.</p> <p>The available properties are:</p> Property Name Required Value Type Description name yes string The name of the project, typically snake_case version yes string The x.y.z version author yes string The author's name description no string A description of the library dependencies no package list A list of packages the library or application depends on provider no Java class string The Java class that implements the <code>ServiceProvider</code> interface, if the library includes a service provider native_bind_factory no Java class string The Java class that implements <code>NativeFunctionBindingFactory</code> to provide native methods' implementations with singleton instances of objects. See Native Binding Factories native_classes no Java class string list A list of Java classes that bind to Qilletni native methods. See Native Methods auto_import no source file list A list of Qilletni source file paths that are included in all files without an explicit <code>import</code>. Note: This should only be used in rare cases <p>The following is an example of all the properties being used:</p> qilletni_info.yml<pre><code>name: spotify\nversion: 1.0.0\nauthor: Adam Yarris\ndescription: A service provider that adds support for Spotify\ndependencies:\n  - 1.0.0:postgres\nprovider: dev.qilletni.music.spotify.provider.SpotifyServiceProvider\nnative_bind_factory: dev.qilletni.lib.spotify.SpotifyNativeFunctionBindingFactory\nnative_classes:\n  - dev.qilletni.lib.spotify.PlayRedirect\n  - dev.qilletni.lib.spotify.PlaylistToolsFunctions\nauto_import:\n  - core.ql\n</code></pre>"},{"location":"project_structure/#dependencies","title":"dependencies","text":"<p>The format for dependencies is</p> <p>// TODO</p>"},{"location":"test/","title":"Playlist","text":""},{"location":"language/documenting_code/","title":"Documenting Code","text":"<p>Qilletni supports its own style of documentation for functions, entities, and fields. This is markdown-based, with some additional structure. Unlike actual signatures, documentation can provide information regarding parameter or return types.</p> <p>The following is an example of documenation from the <code>Map</code> entity in the standard library. To see how it is rendered, see the Qilletni Docs for the entity.</p> <pre><code>/**\n * A [@java java.util.HashMap] wrapper that may store keys and values of any type.\n */\nentity Map {\n\n    /**\n     * The internal [@java java.util.HashMap] object, storing the map's state.\n     * @type @java java.util.HashMap\n     */\n    java _map = _emptyJavaMap()\n\n    /**\n     * Creates a new map from a list of key-value pairs.\n     *\n     * @param[@type list] list A list of key-value pairs\n     * @returns[@type core.Map] A new map with the given key-value pairs\n     */\n    static fun fromList(list) {\n        Map map = new Map()\n        int i = 0\n        for (i &lt; list.size()) {\n            map.put(list[i++], list[i++])\n        }\n\n        return map\n    }\n}\n</code></pre>"},{"location":"language/documenting_code/#documentation-structure","title":"Documentation Structure","text":""},{"location":"language/documenting_code/#type-referencing","title":"Type Referencing","text":"<p>In all text areas, Qilletni supports basic markdown support (no HTML). To reference a Qilletni type, the following syntax may be used:</p> <pre><code>[@type library.EntityName]\n[@type std.Map]\n</code></pre> <p>This is as simple as the library name and the entity name, which will turn into a link to the https://docs.qilletni.dev/ documentation page for the entity.</p> <p>As Qilletni may interface with Java closely, Java types may be referenced too, with the following format:</p> <pre><code>[@java java.util.HashMap]\n</code></pre> <p>This will produce a link to the official Javadocs of the class. These type references may be used in a text area, such as:</p> <pre><code>/**\n * You may reference a [@type std.Map] which is a wrapper around a [@java java.util.HashMap].\n */\n</code></pre>"},{"location":"language/documenting_code/#parameterreturn-type","title":"Parameter/Return Type","text":"<p>Parameters and return types may be referenced in a similar format. Neither are required, but recommended. This may be done by adding parameters at the end of the documentation block prefixed by <code>@param</code> and then a <code>@returns</code>. After that, a type may be provided (but is not required), the name of the parameter (if not a return), and then a description. </p> <p>The following formats are used to reference types after a <code>@param</code> or <code>@returns</code>:</p> Format Example When to use <code>[@type native-type]</code> <code>[@type string]</code> When referencing native types/placeholders: <code>int</code>, <code>double</code>, <code>string</code>, <code>boolean</code>, <code>collection</code>, <code>song</code>, <code>album</code>, <code>list</code>, <code>java</code>, <code>function</code> <code>[@type library.EntityName]</code> <code>[@type std.Artist]</code> When referencing any Entity <code>[@type @java class.path]</code> <code>[@type @java java.time.LocalDate]</code> When referencing an official Java type <p>If referencing a Java type, the format of <code>[@type @java ..]</code></p> <p>The following examples are valid documentation:</p> <pre><code>/**\n * @param[@type list] list                            A list of *key* and *value* pairs\n * @param[@type std.Artist] myArtist                  The artist to follow\n * @param[@type @java java.time.LocalDate] localDate  The [@java java.time.LocalDate] to manipulate\n * @param value                                       The value to process\n * @returns[@type lastfm.Page] The page to return\n */\n</code></pre>"},{"location":"language/documenting_code/#field-type-documenting","title":"Field Type Documenting","text":"<p>Fields can be documented as well, specifically in entities. A normal documentation block can be used, however with the <code>any</code> or <code>java</code> types, some ambiguity may want to be cleared up in docs. The following format, similar to parameter types, may be used to reference a Qilletni or Java field type:</p> <pre><code>/**\n * The internal [@java java.time.LocalDate] object to store the date info.\n * @type @java java.time.LocalDate\n */\njava _date\n\n/**\n * The [@type string] to set.\n * @type string\n */\nany value\n</code></pre> <p>This type must appear at the end of the documentation string.</p>"},{"location":"language/introduction/","title":"Introduction to Qilletni","text":"<p>This page is a brief introduction to Qilletni, with some samples of its main features. To get begin programming in Qilletni, check out the Getting Started guide.</p>"},{"location":"language/introduction/#hello-world","title":"Hello World","text":"<p>When a file is ran or imported, all top-level code is executed in order. This makes simple programs like a Hello World application very easy:</p> <pre><code>print(\"Hello, World!\")\n</code></pre>"},{"location":"language/introduction/#variables","title":"Variables","text":"<p>All variables are assigned a type upon initialization. The concept of a null or empty variable does not exist, so a variable must have a value assigned to it initially, except when declaring an entity (this is more of a late-assignment, and still does not provide value-less variables). Variables are relatively weakly typed, and if initialized with a non-<code>any</code> type, it must adhere to that type.</p> <pre><code>int i = 10\ndouble d = 1.23\nstring s = \"foo bar\"\nsong mySong = \"Spiral\" by \"Feyn Entity\"\nalbum myAlbum = \"Requiem\" album by \"Last Falling Rose\"\nstring[] names = [\"Bob\", \"Tim\"]\nany[] stuff = [\"a string\", 42]\n</code></pre> <p>Some types have unfamiliar syntax than other languages. See the built-in types page to see how to define them and how they work.</p>"},{"location":"language/introduction/#control-flow-statements","title":"Control flow statements","text":"<p>Qilletni supports basic control flow statements, such as:</p> <pre><code>if (age &gt;= 18) {\n    print(\"Is an adult\")\n} else {\n    print(\"Is a minor\")\n}\n\nfor (name : names) {\n    print(name)\n}\n\nfor (i..10) { // Prints 0-9\n    print(i)\n}\n\nfor (i..infinity) { // Prints from 0 to infinity until exited\n    print(i)\n}\n\nfor (i != 0) {\n    i = getNumber()\n}\n</code></pre>"},{"location":"language/introduction/#functions","title":"Functions","text":"<p>Functions are defined without input/return types, typically specified in docs (see Documenting Code).</p> <pre><code>fun fibonacci(n) {\n    if (n == 0 || n == 1) {\n        return n\n    }\n    return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\nint result = fibonacci(10)\n</code></pre> <p>If a method doesn't return anything but is expected to, an error occurs during runtime. If you may not want to return a value, see the Optional type. Functions may also be overridden with a different number of arguments.</p>"},{"location":"language/introduction/#comments","title":"Comments","text":"<p>Comments usually start with <code>//</code></p> <pre><code>// This is a comment\n\n/**\n * This is a documentation comment\n */\n</code></pre> <p>For more information on documentation comments and their standard format, see Documenting Code.</p>"},{"location":"language/introduction/#imports","title":"Imports","text":"<p>Importing libraries or files may be done through a normal <code>import</code> or an aliased import.</p> <pre><code>import \"spotify:play_redirect.ql\"\n\nimport \"spotify:recommendations.ql\" as recommendation\n</code></pre> <p>Unaliased imports put the contents of the imported file in the same scope as the file importing it. Aliased imports make the scope of the imported file accessible through the alias given. In the above example, everything in <code>recommendations.ql</code> is accessible via <code>recommendation.recommendationMethod()</code>.</p>"},{"location":"language/introduction/#entities","title":"Entities","text":"<p>Entities are equivalent to objects/classes in many other programming languages. They have defined properties holding data with functions in it.</p> <pre><code>entity Person {\n    string name\n    int age\n    int armCount = 2\n\n    Person(name, age)\n\n    static fun createChild(name) {\n        return new Person(name, 0)\n    }\n\n    // Instance function: uses the entity's own properties\n    fun introduce() {\n        printf(\"Hi, I'm %s and I'm %d years old! I have %d arms.\", [name, age, armCount]))\n    }\n}\n</code></pre> <p>Static functions are not reliant on an instance of an entity, so the above may be invoked like <code>Person.createChild(\"name\")</code>.</p> <p>Constructors of entities do not contain a body, so initialization logic should rely on a static factory method. Parameters of a constructor should include all uninitialized parameters, as Qilletni requires all values to have a value.</p>"},{"location":"language/service_providers/","title":"Service Providers","text":"<p>Music is handled through a service provider, which is a Qilletni package with additional features. This is often an implementation of an API, such as Spotify, that handles necessary caching and lookups, abstracted by Qilletni's API. This allows for drop-in replacements of what music service is being used. The following is an example of getting a song from the Last.Fm provider. The Last.Fm provider also provides access to API methods to get specific data on the user.</p> <pre><code>import \"lastfm:lastfm.ql\"\n\nprovider \"lastfm\" // (1)!\n\nprint(\"\\tProvider is Last.FM\")\n\nPage page = new Page()\n                ..page = 1\n                ..count = 1\n\nsong topSong = getTopTracks(\"RubbaBoy\", \"7day\", page).data[0] // (2)!\n\nprint(topSong)\n\nprovider \"spotify\" { // (3)!\n    print(\"\\tProvider is Spotify\")\n\n    print(topSong.getId()) // (4)!\n}\n</code></pre> <ol> <li>A <code>provider</code> statement without brackets switches the whole program to use the provider, in this case, Last.Fm</li> <li>Gets a Last.Fm song</li> <li>Everything in this block is now in the Spotify provider, so anything accessed will automatically convert to this service provider</li> <li>Prints the Spotify ID of the song</li> </ol> <p>This results in the following output, which prints out the user's top song from Last.Fm, and then its Spotify ID:</p> <pre><code>        Provider is Last.FM\nsong(\"Late Night Drinking\" by \"nowifi\")\n        Provider is Spotify\n4Xl2xUFmj2xbszjYjEXxkx\n</code></pre> <p>Conversions between service providers are only done if needed, and data is cached for quick switching.</p>"},{"location":"language/service_providers/#syntax","title":"Syntax","text":"<p>Service provider switching may be done two ways, full-program switching or through a block. Full-program switching is done via:</p> <pre><code>provider \"library name\"\n</code></pre> <p>If you are developing a library, be careful with this syntax because the running application may be left off with a different provider than originally intended. The other syntax is safer, and only sets the provider for the given code block:</p> <pre><code>provider \"library name\" {\n    // Code here\n}\n</code></pre> <p>The name of the provider is the library's name.</p>"},{"location":"language/syntax/extension_functions/","title":"Extension Functions","text":""},{"location":"language/syntax/extension_functions/#extension-functions","title":"Extension Functions","text":"<p>Extension functions are functions that may be invoked on an object, like it was an entity that has the function defined in it. They may be applied to any type, using the <code>on</code> keyword in the following format:</p> <pre><code>fun printThis(str) on string {\n    printf(\"Printing this string: ''%s;\", [str])\n}\n\n\"My String\".printThis()  // Prints \"Printing this string: 'My String'\"\n</code></pre> <p>The first parameter of the function definition is the object that the function is bring invoked on. Notice that it is implicitly set, and is not included in the call to the function. Other parameters may be added after that, such as the following:</p> <pre><code>fun printThis(str, n) on string {\n    for (i..n) {\n        printf(\"Printing this string: ''%s;\", [str])\n    }\n}\n\n\"My String\".printThis(2)  // Prints \"Printing this string: 'My String'\" twice\n</code></pre> <p>Extension functions also work for entities.</p> <pre><code>entity Cat {\n    string name\n\n    Cat(name)\n}\n\nfun sayHi(cat) on Cat {\n    printf(\"Hello, %s\", [cat.name])\n}\n\nCat cat = new Dat(\"Olive\")\ncat.sayHi()  // Prints \"Hello, Olive\"\n</code></pre>"},{"location":"language/syntax/extension_functions/#native-method-extensions","title":"Native Method Extensions","text":"<p>Extension methods may be native methods too. The only difference in definition is they don't include the invoked on parameter, and as normal for native functions, don't include a body.</p> <pre><code>native fun sayHi() on Cat\n</code></pre> <p>For implementing these, see Native Methods.</p>"},{"location":"language/syntax/operators/","title":"Operators","text":"<p>The following is an estimation of Qilletni's operator associativity and precedence, from highest to lowest.</p> Description Operator Associativity Notes member access <code>.</code> Left-to-right Accesses properties/functions unary postfix <code>x++</code> <code>x--</code> Left-to-right <code>x++</code> <code>x--</code> increments/decrements after returning the old value unary prefix <code>!</code> <code>++x</code> <code>--x</code> Right-to-left <code>!</code> inverts a boolean, and <code>++x</code> and <code>--x</code> increments/decrements before returning the new value multiplicative <code>*</code> <code>/~</code> <code>/</code> <code>%</code> Right-to-left <code>/~</code> is floor (integer) division, <code>/</code> is floating division, <code>%</code> is modulo additive <code>+</code> <code>-</code> Left-to-right Handles addition/subtraction, <code>+</code> also handles string concatenation between numbers, strings, direct function calls and parentheses-wrapped expressions <code>( expression )</code> range/cascade <code>..</code> Left-to-right Used both in <code>for (i..10)</code> or through cascade assignment <code>foo..bar = 0 ..baz = 1</code> relational <code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code> <code>==</code> <code>!=</code> Left-to-right Compares two expressions, returning a boolean logical AND <code>&amp;&amp;</code> Left-to-right Checks if both sides of the keyword are true logical OR <code>||</code> Left-to-right Checks if at least one side of the keyword is true type check <code>is</code> Left-to-right Checks the type of a variable assignment <code>=</code> <code>+=</code> <code>-=</code> Right-to-left <code>=</code> is not an expression, and does not return a value <p>Most operators create an expression. The only exceptions are assignment and range/cascade. Operators that may require some additional information are outlined below. Most are used how you would expect.</p>"},{"location":"language/syntax/operators/#type-checking","title":"Type checking","text":"<p>Qilletni has relatively loose type checking, mainly in function parameters. The <code>as</code> operator is used to check what a variable is set to.</p> <pre><code>any a = \"Hello\"\n\nprintf(\"a = %s\", [a is string]) // prints \"a = true\"\n\na = 123\n\nprintf(\"a = %s\", [a is string]) // prints \"a = false\"\nprintf(\"a = %s\", [a is int])    // prints \"a = true\"\n</code></pre> <p>The <code>as</code> operator may check if something is any native type or entity name. It may not be used to check if something is <code>any</code>, as everything is <code>any</code>.</p>"},{"location":"language/syntax/operators/#cascade-notation","title":"Cascade notation","text":"<p>Cascade notation is a special form of assignment used with entities. Instead of returning nothing, the operator returns the result of the expression on the left, allowing for combined assignments. Take this code, which uses traditional assignment:</p> <pre><code>Coord coordinate = new Coord()\ncoordinate.x = 1\ncoordinate.y = 2\ncoordinate.z = 3\n</code></pre> <p>The cascade operator would allow you to do:</p> <pre><code>Coord coordinate = new Coord()\n    ..x = 1\n    ..y = 2\n    ..z = 3\n</code></pre> <p>In one single expression.</p>"},{"location":"language/syntax/operators/#range-notation","title":"Range notation","text":"<p>The range operator is unique to the <code>for</code> loop. It allows the specification of when the loop should end. Loops are relatively primitive, in that with built-in syntax, they always start with 0 and go to an exclusive number. Examples of this notation are:</p> <pre><code>for (i..10) { // // Prints 0-9\n    print(i)\n}\n\nfor (i..infinity) { // Prints from 0 to infinity until exited\n    print(i)\n}\n</code></pre> <p>Note that <code>infinity</code> may also follow the range operator, making the loop repeat forever until it is exited out of.</p>"},{"location":"language/types/built_in_types/","title":"Built-in types","text":"<p>Qilletni comes with following primary types to get started with in its standard library:</p> <ul> <li>Numbers (<code>int</code>, <code>double</code>)</li> <li>Strings (<code>string</code>)</li> <li>Booleans (<code>boolean</code>)</li> <li>Lists (<code>type[]</code>)</li> <li>Maps (<code>Map</code>)</li> <li>Optional (<code>Optional</code>)</li> <li>Any (<code>any</code>) // TODO</li> <li>Songs (<code>song</code>)</li> <li>Albums (<code>album</code>)</li> <li>Playlists (<code>collection</code>)</li> <li>Artists (<code>Artist</code>)</li> <li>Weights (<code>weights</code>)</li> <li>Java Reference (<code>java</code>)</li> </ul>"},{"location":"language/types/built_in_types/#numbers","title":"Numbers","text":"<p>Numbers in Qilletni are relatively rudimentary. There are two types, <code>int</code> and <code>double</code>. <code>int</code>s can go from <code>`-2^31</code> to <code>2^31 - 1</code>, whereas <code>double</code>s are floating points, and follow the IEEE 754 standard for 64-bit floating point numbers.</p> <p><code>int</code>s and <code>double</code>s may be converted to one another, via the syntax below.</p> <pre><code>double d = 3.14\n\nint i = int(d)\nprint(i)  // Prints \"3\"\n\ndouble d2 = double(i)\nprint(d2)  // Prints \"3.0\"\n</code></pre> <p>If math operations go between both <code>int</code>s and <code>double</code>s, generally they will return as a <code>double</code>. Exclusions for this are addition, subtraction, and integer division.</p>"},{"location":"language/types/built_in_types/#strings","title":"Strings","text":"<p>Strings are immutable sequences of characters. They may be formatted via</p> <pre><code>\"Number: %d  Float (3 decimal places): %.3f  String: %s\".format([123, 3.14159, \"hello\"])\n// Outputs:\n//   Number: 123  Float (3 decimal places): 3.142  String: hello\n</code></pre> <p>The <code>format</code> method takes in an array of expressions to format with the string. For simplicity, formatting follows Java's implementation, outlined here.</p> <p>The same can be done with <code>printf</code>:</p> <pre><code>printf(\"Hello %s!\", [\"World\"])  // Prints \"Hello World!\"\n</code></pre> <p>Which is a formatting variation of the <code>print</code> command. Strings may also be escaped with a backslash: <pre><code>print(\"Hello \\\"World!\\\"\")  // Prints 'Hello \"World!\"'\n</code></pre></p>"},{"location":"language/types/built_in_types/#lists","title":"Lists","text":"<p>Lists are ordered collections of either built-in types or entity instances, that may be manipulated. They may ether be created explicitly with a type or have its type assumed implicitly.</p> <pre><code>string[] strs1 = [\"a\", \"b\", \"c\"]  // Implicit type\nstring[] strs2 = string[\"d\", \"e\", \"f\"]  // Explicit type\n\nany[] strs3 = [\"g\", \"h\", \"i\"]  // Implicitly a string[]\nany[] strs4 = string[\"j\", \"k\", \"l\"]  // Explicitly a string[]\n\nprint(strs1 is string[])\nprint(strs2 is string[])\nprint(strs3 is string[])\nprint(strs4 is string[])\n\nstrs1 = [1, 2, 3]  // Errors!\n//      ^ Even through the original list was defined with an implcit type, the variable retains its set type forever\n\nany[] ints = [1, 2, 3]  // Implicit type\nstrs3 = [1, 2, 3]\n\nprint(ints is int[])  // true\nprint(strs3 is int[])  // true\nprint(strs3 is string[])  // false  strs3 was any any[] but is not an int[]\n\nstring[] uhOh = string[1, \"b\", 3.0]  // Errors!\n//              ^ Cannot force all of these types to be strings\n</code></pre>"},{"location":"language/types/built_in_types/#implicit-subtypes","title":"Implicit subtypes","text":"<p>Every list has a subtype. A list's subtype may either be defined explicitly in the list expression, or implicitly in the expression. As per normal variables, once a variable is defined with a type, it may not change. The below example shows a list variable being created with a defined type <code>string[]</code> but then assigned to a  list with an implicitly defined type. This list variable is forever a <code>string[]</code>.</p> <pre><code>string[] strs1 = [\"a\", \"b\", \"c\"]  // Implicit type\n\nstrs1 = [1, 2, 3]  // Errors!\n//      ^ Even through the original list was defined with an implcit type, the variable retains its set type forever\n</code></pre> <p>If a list is created with an implicit type and not all types are the same in the list, it is assumed an <code>any[]</code>, as shown below.</p> <pre><code>any[] mixed = [1, \"b\", 3.0]\n</code></pre> <p>An <code>any</code> list may also be created with a consistent type. This means the actual containing list has a type, but the variable could be reassigned to a list with another type. This is done through a type assumption of its contents upon creation.</p> <pre><code>any[] consistent = [1, 2, 3]\nprint(consistent is int[])  // true\n\nconsistent = [\"a\", \"b\", \"c\"]\nprint(consistent is string[])  // true\n\nconsistent = any[1, 2, 3]\nprint(consistent is int[])     // false\nprint(consistent is string[])  // false\n</code></pre> <p>The end of the above example demonstrates that <code>any</code> is also a type, and a list can be created with that as its subtype. This means any value could be added to the list in the future, despite it currently containing only one type. No type assumptions are made in an <code>any[]</code> definition.</p>"},{"location":"language/types/built_in_types/#explicit-subtypes","title":"Explicit subtypes","text":"<p>Explicit subtypes are fairly straightforward. They are useful when you are passing in parameters to a function, where you want a strict type on the list, or perhaps an empty list where no type assumptions can be made. </p> <pre><code>fun handleList(list) {\n    if (list is string[]) {\n        print(\"String list\")\n    } else if (list is int[]) {\n        print(\"Int list\")\n    } else {\n        print(\"Unknown list\")\n    }\n}\n\nhandleList(string[\"a\", \"b\", \"c\"])  // Prints \"String list\"\nhandleList(int[1, 2, 3])  // Prints \"Int list\"\nhandleList(int[])  // Prints \"Int list\"\nhandleList([])  // Prints \"Unknown list\"  - No explicit subtype\n</code></pre>"},{"location":"language/types/built_in_types/#subtype-transformations","title":"Subtype transformations","text":"<p>Sometimes when a list is created, it may have ambiguous types that should actually be all the same. An example of this is if a list of song IDs (strings) are present in a <code>song[]</code>. The Qilletni feature of subtype transformations allow the system to attempt to convert the string to the real type.</p> <pre><code>song[] songs = song[\"0PmoG29VeyZEEWuSJyfizZ\", \"https://open.spotify.com/track/58z4qdwM0zpWJEGfjSptR7?si=1d6a32c7f04b4c98\", \"6BVH6nyMBj601mSaUbbqKc\"]\nprint(songs)\n// ^ Prints: [song(\"Deception\" by \"Glae\"), song(\"Feel the Pressure\" by \"DRAIN\"), song(\"Where Light Divides the Holler\" by \"Knocked Loose\")]\n</code></pre> <p>This feature only works with expressions that would normally be able to be assigned to their type, such as an ID or URL string. This only works with lists of an explicit type, so the following would NOT work:</p> <pre><code>song[] songs = [\"0PmoG29VeyZEEWuSJyfizZ\", \"6BVH6nyMBj601mSaUbbqKc\"]  // Errors! This assigns a string[] to a song[]\n</code></pre> <p>The following table shows the supported type transformations.</p> From Type To Type Description of input <code>string</code> <code>song</code> ID or URL of the song <code>string</code> <code>album</code> ID or URL of album <code>string</code> <code>collection</code> ID or URL of collection <code>int</code> <code>double</code> Any int"},{"location":"language/types/built_in_types/#maps","title":"Maps","text":"<p>Maps are a normal Qilletni entity, acting as a wrapper of Java's HashMap. They may be created with <code>new Map()</code> or <code>Map.fromList()</code> which takes in a list of even size and pairs items together. They may store anything.</p> <pre><code>Map map = new Map()\nmap.put(\"a\", 1)\nmap.put(\"b\", 2)\nprint(map.get(\"a\"))  // Prints: \"1\"\n</code></pre>"},{"location":"language/types/built_in_types/#optional","title":"Optional","text":"<p>Because Qilletni doesn't support the concept of an empty/null value, Optionals are used to ensure the programmer is always aware of when a value isn't present. They typically should only be used for return values.</p> <p>The Optional entity defines the following static methods to create an Optional:</p> <pre><code>Optional a = Optional.fromEmpty()\nOptional b = Optional.fromValue(\"Hello\")\n</code></pre> <p>An Optional can have its empty status checked with <code>hasValue()</code> and have its value inspected with <code>getValue()</code>. The latter will exit the program and throw an error if no value is found in the optional.</p> <pre><code>Optional a = Optional.fromEmpty()\n\nprintf(\"Value: %b\", [a.hasValue()])  // Prints \"false\"\n\nany aValue = a.getValue()  // Errors! No value is found\n</code></pre>"},{"location":"language/types/built_in_types/#music-types","title":"Music Types","text":"<p>Qilletni's whole purpose is dealing with music, so certain functions are baked into the language to assist with that.</p> <p>All music data is handled by the currently active Service Provider. A service provider assumes there is an ID present for each song, album, collection, and artist. The individual service provider has the ability to parse URLs to extract the relevant ID present. For examples, assume whenever you see an ID, a URL may also be passed in.</p> <p>If the internal package config property <code>eagerLoad</code> is <code>true</code>, the music type will be immediately queried, and will error out if invalid. If the property is not found or <code>false</code>, it will be queried whenever the first method that references a property of the type is invoked. See the following example where <code>eagerLoad</code> is <code>false</code>:</p> <pre><code>song mySong = \"Haunted\" by \"Burdened Hearts\"  // Song is not loaded yet, no API calls have been made\n\nprint(mySong.getAlbum())  // The song is queried. Prints 'album(\"The Best of Times\" by \"Burdened Hearts\")'\n</code></pre> <p>When using a title and an artist, native music types are defined by the following syntax:</p> <pre><code>&lt;type&gt; &lt;variable name&gt; = &lt;title&gt; &lt;type&gt; by &lt;artist&gt;\n</code></pre> <p>By default, the <code>&lt;type&gt;</code> before <code>by</code> defaults to <code>song</code>, so it may not be included. So for example, definitions may be</p> <pre><code>song s1 = \"Impulse\" by \"Harroway\"\nsong s2 = \"Heavy Rain\" song by \"Konami Kode\"\nalbum a1 = \"Nublar\" album by \"XO Armor\"\ncollection c1 = \"Polish RAVE\" collection by \"rubbaboy\"\n</code></pre>"},{"location":"language/types/built_in_types/#songs","title":"Songs","text":"<p>The <code>song</code> type in Qilletni represents a song that may be played on a streaming service. A service provider may also count something like a podcast as a song. It is uniquely identified by an ID, identified (sometimes ambiguously) by one or more artists and a title, and has an album. A <code>song</code> may be defined by the following:</p> <pre><code>song s1 = \"Fauna\" by \"Apothica\"\nsong s2 = \"2HdTQdGeProvKc35VdNfhD\"\nsong s3 = \"https://open.spotify.com/track/2HdTQdGeProvKc35VdNfhD?si=3060f8808cdd4d8c\"\n</code></pre> <p>All the above songs define the same song. For a song to be added to the queue, playlist, etc. the <code>play</code> keyword is used. By default, this adds it to the queue, however it may be redirected to perform other actions, dependent on the service provider.</p> <pre><code>play \"Dirty Floor\" by \"Sypha\"  // Adds the song to the queue\n</code></pre> <p>An example from the spotify library to add songs to a list is:</p> <pre><code>// Route all played songs to this list\nsong[] songList = []\nredirectPlayToList(songList)\n\nplay \"Child's Play\" by \"Hara Kiri\"\nplay \"Terror\" by \"Dread Engine\"\n\nprint(songList)  // Prints: '[song(\"Child's Play\" by \"Hara Kiri\"), song(\"Terror\" by \"Dread Engine\")]'\n</code></pre> <p>This may be useful if you want to batch add songs to a playlist, perform some kind of analysis on it, etc.</p> <p><code>play</code> redirects are covered more (// TODO)</p>"},{"location":"language/types/built_in_types/#albums","title":"Albums","text":"<p>The <code>album</code> type represents an album that songs may be on, with an ID, name, and one or more artists. An album may be defined by:</p> <pre><code>album a1 = \"Here &amp; Now\" album by \"Framework\"\nalbum a2 = \"7ulI5y1UiuepuQD61gcKHo\"\nalbum a3 = \"https://open.spotify.com/album/7ulI5y1UiuepuQD61gcKHo?si=1Ip8PdIdTQKCtlJiXFhyIg\"\n</code></pre> <p>The above album definitions all represent the same albums.</p> <p>Planned Feature</p> <p>Fetching songs from albums is a planned feature. It is already possible natively from within a service provider.</p>"},{"location":"language/types/built_in_types/#playlists","title":"Playlists","text":"<p>In Qilletni, a playlist is abstracted as a <code>collection</code>. A collection is what it sounds like, a collection of songs. A collection may be more than just a playlist though, it may be dynamically created from a list of songs, or may represent some other kind of song list sourced by a service provider (a list of top songs, for instance). A collection contains some basic information regarding it, such as the ID, the creator, song count, songs, and name. A collection may be defined as the following:</p> <pre><code>collection c1 = \"rage death kill\" collection by \"rubbaboy\"\ncollection c2 = \"2fupEjJ1lamW0dfAsXJag6\"\ncollection c3 = \"https://open.spotify.com/playlist/2fupEjJ1lamW0dfAsXJag6?si=45dd2429fd0a46ba\"\ncollection c4 = collection([\"Empath\" by \"Fayne\", \"Full Tilt\" by \"Johnny Booth\", \"7L7\" by \"Above This\"])  // Creates an in-memory collection with 3 songs in it\n</code></pre> <p>The above collections (aside from the last) all define the same playlist. <code>c4</code> is defined by a cast-like syntax, taking in a song list within the <code>collection( )</code>. The created collection doesn't exist other than in the program's memory, but may act like any other collection.</p> <p>A collection may also have weights assigned to it, along with an order, in the syntax of:</p> <pre><code>collection c1 = \"Chill Bruh Moment\" by \"rubbaboy\" order[shuffle] weights[myWeights]\n</code></pre> <p>Where <code>myWeights</code> is a variable of type <code>weights</code>. <code>order</code> may either by \"shuffle\" or \"sequential\", defaulting to the former if unspecified. To see more information regarding weights, see Weights.</p> <p>Collections may be played in a similar way playlists are, just with an additional option.</p> <pre><code>play \"96 crayons\" by \"rubbaboy\" limit[10]\n</code></pre> <p>The above will play 10 shuffled songs from the given playlist. Instead of a number, the limit parameter may also be a time, such as <code>1h</code> to play 1 hour of songs (it will stop as soon as 1+ hour has been hit) or <code>15m</code> for 15 minutes of songs.</p> <p>Note this may also be given a variable, as the above is simply an expression.</p> <pre><code>play myPlaylist limit[30m]  // Plays 30 minutes of songs\n</code></pre>"},{"location":"language/types/built_in_types/#artists","title":"Artists","text":"<p>Artists aren't handled as natively as other music types are, as they are an entity. The entity consists of a name and a unique ID. Below are examples of getting an artist:</p> <pre><code>song mySong = \"Orchid Street\" by \"Arimea\"\n\nArtist artist = mySong.getArtist()\nprintf(\"Artist id: '%s' name: '%s'\", [artist.getId(), artist.getName()])  // Prints \"Artist id: '6qNHuzJVAGJ8h2D0qo6wAh' name: 'Arimea'\"\n</code></pre>"},{"location":"language/types/built_in_types/#weights","title":"Weights","text":"<p>Weights in Qilletni are a unique way of playlist orchestration. They manipulate the way Qilletni chooses which songs to play while playing from a collection. The following is an example of a simple weight definition.</p> <pre><code>weights demoWeights =\n    | 25% \"MANGO\" by \"This Is Falling\"\n    | 25% \"Reflections\" by \"I Sworn\"\n</code></pre> <p>The above weights, when applied to a collection, make \"MANGO\" play 25% of the time, for every song picked from the playlist. Likewise, \"Reflections\" is played 25% of the time, independently to anything else. For percent multipliers, the song doesn't necessarily have to be in the collection it's applied to. If all the percent multipliers add up to 100%, the songs in the collection will be ignored. Note the separator <code>|</code>. This disallows for the songs to repeat, allowing for a less repetitive mix. To fine tune this, see Weight Separators.</p> <p>Below is a visualization of a normal random shuffle of 20 songs through a playlist, and the same playlist with weights applied. The playlist consists of 10 songs, including \"MANGO\" and \"Reflections\". In the rest of this, the same playlist and visualization techniques will be used, just with different weights to highlight differences.</p>"},{"location":"language/types/built_in_types/#nested-weights","title":"Nested Weights","text":"<p>Weights can give you some more advanced control over how your songs are chosen from weights. Nested weights allow for the system to choose a song from a child weight every time the parent weight is chosen. Child weights (ones that are nested) must contain only percentages that add up to 100%, as something from it is always chosen. For example, the below code is equivalent to the previous example:</p> <pre><code>weights childWeights =\n    | 50% \"MANGO\" by \"This Is Falling\"\n    | 50% \"Reflections\" by \"I Sworn\"\n\nweights demoWeights =\n    | 50% childWeights\n</code></pre> <p>This is equivalent because originally, each song had a 25% chance of being chosen. <code>childWeights</code> has a 50% chance of being chosen, and each song in <code>childWeights</code> has an additional 50% chance. <code>0.50 * 0.50 = 0.25 = 25%</code></p>"},{"location":"language/types/built_in_types/#function-call-weights","title":"Function Call Weights","text":"<p>Along with nested weights, weights allow for function calls instead of chosen a song from a child weight. This acts the same as adding a child weight, but with a function (optionally with parameters) that is evaluated every time the weight is chosen. The function must always return a song. The following example is also equivalent to the last two.</p> <pre><code>fun mySongFunction() {\n    if (random(0, 10) &lt; 5) {  // 50% of the time\n        return \"MANGO\" by \"This Is Falling\"\n    } else {\n        return \"Reflections\" by \"I Sworn\"\n    }\n}\n\nweights demoWeights =\n    | 50% mySongFunction()\n</code></pre>"},{"location":"language/types/built_in_types/#collection-weights","title":"Collection Weights","text":"<p>Weights may also use a collection to choose what song to play when a weight is selected. The song is selected as it would normally be played from the collection. This includes its own weights, ordering, etc. For example, these are two code examples, one with a collection that's shuffled, and onme that is ordered, and a visualization of their outputs. The playlist <code>child playlist</code> contains the songs <code>\"I\"</code>, <code>\"II\"</code>, and <code>\"III\"</code>.</p> <pre><code>weights demoWeights =\n    | 50% \"child playlist\" collection by \"rubbaboy\"  // By default shuffled\n\nweights demoWeights =\n    | 50% \"child playlist\" collection by \"rubbaboy\" order[sequential]\n</code></pre> <p>As you can see, when the child playlist is sequential, each time a song is selected from the collection, it is the next song in the collection.</p>"},{"location":"language/types/built_in_types/#list-weights","title":"List Weights","text":"<p>Similar to collection weights, a weight may take in a list of songs as shorthand to defining a collection expression. This is functionally a shorthand of creating a collection that is shuffled. Each time a song is selected from the list, it is randomly chosen and played. Below is an example of a shorthand list weight, and then the equivalent with using a <code>collection</code>.</p> <pre><code>weights demoWeights =\n    | 50%  [\"I\" by \"BLACKSHAPE\", \"II\" by \"BLACKSHAPE\", \"III\" by \"BLACKSHAPE\"]\n\nweights demoWeights =\n    | 50%  collection([\"I\" by \"BLACKSHAPE\", \"II\" by \"BLACKSHAPE\", \"III\" by \"BLACKSHAPE\"]) order[shuffle]\n</code></pre>"},{"location":"language/types/built_in_types/#weight-separators","title":"Weight Separators","text":"<p>Weights also allow for more fine grain control. The separator before each line in the weights <code>|</code> may be replaced with one of the following. The below table shows the separator and what it does when the weight is selected. In the context of the table, an individual weight is the line in the <code>weights</code> expression. So it may be a song, function call, weight, or a collection.</p> Separator Character Song Repeats Weight Repeats Description <code>|</code> This song may not be chosen next, but the weight may be <code>|!</code> Both the song/line and the weight may be chosen next <code>|~</code> Neither the song nor the weight may be chosen next <p>The column Song Repeats is the song that is chosen from the collection, function, etc. If applied to a single song, the Weight Repeats column may be the same as the Song Repeats column.</p> <p>Below is another visualization of using the separators, using the following code:</p> <pre><code>weights childWeights =\n    | 50% \"MANGO\" by \"This Is Falling\"\n    | 50% \"Reflections\" by \"I Sworn\"\n\nweights demoWeights =\n    | 50% childWeights\n\nweights demoWeights =\n    |! 50% childWeights\n\nweights demoWeights =\n    |~ 50% childWeights\n</code></pre>"},{"location":"language/types/built_in_types/#multiplicative-weights","title":"Multiplicative  Weights","text":"<p>A less obtrusive way of shuffling a playlist is using multiplicative weights. Instead of having a set probability for every time a song is played, they simply increase the chance a song is played. This takes the following format:</p> <pre><code>weights demoWeights =\n    | 5x \"Reflections\" by \"I Sworn\"\n</code></pre> <p>\"Reflections\" is played 5x as often as it normally would, assuming it is in the collection (if it's not, it will do nothing). In other words, imagine the collection was taken and \"Reflections\" was in there once. This will act as if it was in it 5 times. If it was originally in the collection twice, it will show up 10 times.</p> <p>Let's say the collection has 10 songs in it, one being \"Reflections\". The following is a shuffle of 20 songs from the playlist, before and after the 5x multiplicative weight.</p>"},{"location":"language/types/built_in_types/#java-references","title":"Java References","text":"<p>Java references are useful for interfacing with native methods that may require some special data to be associated with the field (or often times with the containing entity). A java reference may be assigned with either the keyword <code>empty</code> to signify a null Java reference internally, or as a return value from a function (usually a native function).</p> <pre><code>java myRef = empty\njava funcRet = someNativeMethod()\n</code></pre> <p>To see more how a Java reference is used, see the Native Binding Reference.</p>"},{"location":"language/types/entities/","title":"Entities","text":"<p>An entity in Qilletni is a reusable template/blueprint that contains a set number of fields and methods in its own scope, that may be instantiated to encapsulate data. In Java, this would be considered a class.</p> <p>An entity is relatively basic, the following is an example of some of the features supported.</p> <pre><code>entity User {\n    int _id // (1)!\n    string username\n    boolean alive = true // (2)!\n\n    User(_id, username) // (3)!\n\n    /* (4)! */static fun createPerson(username) {\n        int id = random(0, 100)\n        return new User(id, username)\n    }\n\n    fun getId() {\n        return _id\n    }\n}\n\nUser user = User.createPerson(\"bob\")\nprint(user)  // Prints: \"User(alive = true, _id = 0, username = bob)\"\n</code></pre> <ol> <li>A private field, that can not be accessed outside the entity</li> <li>A predefined field, that can not be in the constructor</li> <li>A constructor is required with all the fields without values</li> <li><code>static</code> methods may be invoked without an instance of the entity, such as <code>User.createPerson</code></li> </ol> <p>Below is an in-depth overview of all supported features of an entity.</p>"},{"location":"language/types/entities/#fields","title":"Fields","text":"<p>An entity has a constant set of fields, meaning more fields may not be added during runtime. As with any variable in Qilletni, a field may not have no value, so fields must be either have a value given or be specified in the constructor.</p> <p>Accessing a field in an entity is done with the accessor notation, <code>.</code></p> <pre><code>User user = new User(1, \"Alice\")\n\nprint(user.username)\nuser.username = \"Jane\"\n</code></pre> <p>Fields that begin with an underscore may not be accessed from outside of the entity.</p> <pre><code>int i = user._id  // Invalid\n</code></pre> <p>It is standard to use public fields and not getters unless needed.</p>"},{"location":"language/types/entities/#constructors","title":"Constructors","text":"<p>A constructor is very simple, and only sets uninitialized fields in the entity. It does not support code execution upon initialization, for that it is recommended to use a static method initializer. The order of fields in a constructor don't matter, and may use private fields.</p>"},{"location":"language/types/entities/#functions","title":"Functions","text":"<p>Functions may be defined in an entity like a normal method. Similarly to fields, functions that begin with an underscore may not be accessed outside of the entity.</p>"},{"location":"language/types/entities/#static-functions","title":"Static Functions","text":"<p>Static functions do not need to be accessed with an instance of the entity, so they don't have access to any fields the entity has. They are used usually for initialization of an entity that may need special restrictions or code invoked during initialization.</p> <pre><code>entity Car {\n    int speed\n\n    Car(speed)\n\n    static fun create() {\n        return new Car(0)\n    }\n\n    fun getSpeed() {\n        return speed\n    }\n}\n\nCar.create()    // Returns new Car\nCar.getSpeed()  // Error, must be invoked on an instance of Car\n</code></pre>"},{"location":"language/types/type_system/","title":"Type System","text":"<p>Qilletni has a relatively simple type system.</p>"},{"location":"misc/hosting_docs/","title":"Hosting Docs","text":"<p>Qilletni may generate docs for a package in a stateful way, allowing for cross-package references for extension methods. For instance, if you have package A with an entity, and package B has an extension method on that entity, when you generate docs, it will update the docs for package A to show the extension method, making it easier to see what functions are available for each type.</p> <p>Because of this, a stateful cache of the parsed packages is needed. When a package's docs are generated, the internal structure of each file is cached, so the system can easily add extension methods on cross-referenced types.</p> <p>The following is a guide on setting up a server to host the docs on. Doc generation is kicked off from a GitHub Actions runner. On the server when docs are being generated, first the latest Qilletni toolchain is pulled down, and then the library's repository is cloned. All generation occurs in a docker container. Note that docs may also be generated locally, without the need of a server.</p>"},{"location":"misc/hosting_docs/#setting-up-the-server","title":"Setting Up The Server","text":"<p>The below commands should be ran on a server. This creates a user, and sets up access so GitHub Actions can kick off the doc generation process.</p> <p>First, create the user:</p> <pre><code>sudo adduser --disabled-password --gecos \"\" github-deploy\nsudo usermod -aG docker github-deploy\nsudo usermod -aG qilletni github-deploy\n</code></pre> <p>Then, create the ssh key for authentication.</p> <pre><code>sudo mkdir -p /home/github-deploy/.ssh\nsudo chown github-deploy:github-deploy /home/github-deploy/.ssh\nsudo chmod 700 /home/github-deploy/.ssh\n</code></pre> <pre><code>sudo -u github-deploy ssh-keygen -t ed25519 -f /home/github-deploy/.ssh/deploy_key -N \"\"\n</code></pre> <p>Lock down the user to only run a script <code>run_docs_wrapper.sh</code> which will be created later.</p> <pre><code>sudo bash -c 'cat &lt;&lt;EOF &gt; /home/github-deploy/.ssh/authorized_keys\ncommand=\"/usr/bin/sudo /opt/qilletni/run_docs_wrapper.sh\",no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty $(cat /home/github-deploy/.ssh/deploy_key.pub)\nEOF'\n</code></pre> <p>Set the permissions of the authorized keys file.</p> <pre><code>sudo chown github-deploy:github-deploy /home/github-deploy/.ssh/authorized_keys\nsudo chmod 600 /home/github-deploy/.ssh/authorized_keys\n</code></pre> <p>Allow root access on the script.</p> <pre><code>sudo bash -c 'echo \"github-deploy ALL=(root) NOPASSWD: /opt/qilletni/run_docs_wrapper.sh\" &gt;&gt; /etc/sudoers.d/github-deploy'\n</code></pre> <p>Now the <code>github-deploy</code> user can only run the script that generates the docs. To get these scripts, copy the QilletniToolchain/deploy directory contents to the server's <code>/opt/qilletni</code> directory, and run</p> <pre><code>sudo chmod 2775 /opt/qilletni/\nsudo chown -R :qilletni /opt/qilletni/\n</code></pre> <p>Lastly, in the <code>run_docs.sh</code> file downloaded, change the <code>SERVE_PATH</code> variable at the top to the root destination of all generated docs' static HTML, such as</p> <pre><code>SERVE_PATH=\"/srv/docker/nginx\"\n</code></pre> <p>To specify the names of documentable libraries, edit the <code>allowed_releases.json</code> file. The format is shown below.</p> <pre><code>{\n  \"releases\": [\n    { \"name\": \"std\", \"repo\": \"RubbaBoy/Qilletni\", \"qilletni-src\": \"qilletni-std-lib/qilletni-src\" }\n  ]\n}\n</code></pre> <p>The <code>name</code> is the library name, the <code>repo</code> is the GitHub account/repo name to the source to download, the <code>qilletni-src</code> is the path relative to the repository to grab the sources from. This is useful if a GitHub repository contains multiple libraries in it. Only libraries added may be documented from GitHub Actions.</p> <p>Required but not covered here is a webserver to host the generated static files, such as nginx.</p>"},{"location":"misc/hosting_docs/#setting-up-github-actions","title":"Setting Up GitHub Actions","text":"<p>To generate docs through a GitHub Action, a step must be added to your workflow to run an SSH command of a library name. The command is just the library name, as it is passed in as a parameter to <code>run_docs_wrapper.sh</code>. The following is a simple workflow to document the <code>spotify</code> library, ran when manually executed.</p> <pre><code>name: Generate Docs For Library\n\non:\n  workflow_dispatch:\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Trigger Server Deployment via SSH\n        uses: appleboy/ssh-action@v0.1.8\n        with:\n          host: ${{ secrets.SERVER_HOST }}\n          username: ${{ secrets.SERVER_USER }}\n          key: ${{ secrets.SERVER_SSH_KEY }}\n          # The command here is simply the library name.\n          # The forced command in authorized_keys will override the command and\n          # invoke /usr/bin/sudo /opt/qilletni/run_docs_wrapper.sh, which reads\n          # SSH_ORIGINAL_COMMAND. In this case, SSH_ORIGINAL_COMMAND will be the library name.\n          script: \"spotify\"\n</code></pre> <p>Then, set env secrets for the action:</p> <pre><code>SERVER_HOST = your_ip\nSERVER_USER = github-deploy\nSERVER_KEY = contents of /home/github-deploy/.ssh/deploy_key\n</code></pre> <p>From here, once the workflow is triggered, the docs will be pulled down and generated.</p>"},{"location":"native_binding/background_tasks/","title":"Background Tasks","text":"<p>The Qilletni language itself is strictly single threaded, and does not have plans to become multithreaded. Native methods in Java, however, may call Qilletni code from another thread with the use of background tasks through the BackgroundTaskExecutor. This is useful when a native method is polling an API, waiting for an IPC call or webhook, and then needs to tell Qilletni about it. This also lets Qilletni be useful in a server context.</p> <p>A background task is broken down into two parts: a callback and a condition. A callback is a Runnable or a Consumer that is invoked when a condition is triggered. A condition is identified by an ID, and may be triggered in any Java thread. The callback is always ran on the Qilletni thread, which may do normal Qilletni operations, such as invoking a function or modifying a variable.</p> <p>The following is an example of creating a condition and getting its ID.</p> <pre><code>// BackgroundTaskExecutor backgroundTaskExecutor; FunctionType callback;  TypeConverter typeConverter;  FunctionInvoker functionInvoker;\n\nfinal int conditionId = backgroundTaskExecutor.runWhenCondition((String songName) -&gt; {  // (1)!\n    List&lt;QilletniType&gt; args = typeConverter.convertToQilletniTypes(List.of(songName));  // (2)!\n    functionInvoker.invokeFunction(callback, args);\n});\n</code></pre> <ol> <li>Everything ran in this method is on the Qilletni thread</li> <li>Create the arguments from a Java list to QilletniType list</li> </ol> <p>The above code tells the BackgroundTaskExecutor to run the given Consumer when returned <code>conditionId</code> is triggered. The way to trigger this condition is:</p> <pre><code>backgroundTaskExecutor.triggerCondition(conditionId, \"My Song\");\n</code></pre> <p>In this instance, the Consumer accepted a string. This could be any object, which allows cross-thread parameters. Note that you must do any Qilletni type conversion in the callback.</p>"},{"location":"native_binding/introduction/","title":"Native Bindings","text":"<p>Native bindings in Qilletni allow for the use of Java code in a normal program to add functionality either computationally expensive or otherwise impossible in the language itself. Currently, bindings use native methods (which are the things actually bound to Java methods) and the <code>java</code> type which may hold a reference to a Java object, accessible through a native method.</p> <p>See the following resources for more information regarding native bindings:</p> <ul> <li>Native Methods to see how native methods are set up and work</li> <li>Native Bind Factories to see how custom objects can be injected into native method's classes</li> <li>Usage Examples for more advanced examples of how native binding works, including property accessing and invoking Qilletni methods from a Java method</li> </ul> <p>These pages will assume you have a project set up with native bindings enabled. See the Project Structure section on this for setting it up.</p>"},{"location":"native_binding/native_bind_factories/","title":"Native Bind Factories","text":"<p>Native bind factories are used to add instances of a class to the system to allow it to be injected into the constructor that contains a native method.</p> <p>The following is an example of using injected instances:</p> <pre><code>public class MyLibraryFunctions {\n\n    private final EntityInitializer entityInitializer;\n    private final SongTypeFactory songTypeFactory;\n\n    public MyLibraryFunctions(EntityInitializer entityInitializer, SongTypeFactory songTypeFactory) {\n        this.entityInitializer = entityInitializer;\n        this.songTypeFactory = songTypeFactory;\n    }\n}\n</code></pre> <p>The order of the parameters don't matter, nor do they necessarily need to be set to a class member variable, but it is recommended to. It is not recommended to execute code in the constructor, that should be reserved for methods annotated with @BeforeAnyInvocation as outlined here.</p>"},{"location":"native_binding/native_bind_factories/#predefined-injectable-classes","title":"Predefined Injectable Classes","text":"<p>Below is a list of all classes that are injectable by default, with a brief description of their purpose.</p> Class Description MusicPopulator Often ran in a @BeforeAnyInvocation method, this force-populates a given music type with its service provider data, as lazy loading of types may allow there to be no lookup of the type yet EntityDefinitionManager Handles lookups and defining entities EntityInitializer Initializes entities by name or definition with constructor args, supporting auto-conversion of types ListInitializer Creates ListTypes from values, either Qilletni or Java. SongTypeFactory Creates a SongType from a Track CollectionTypeFactory Creates a CollectionType from a Playlist AlbumTypeFactory Creates an AlbumType from an Album FunctionInvoker Invokes a Qilletni function, allowing for callbacks TypeConverter Converts Qilletni types to Java types and back DynamicProvider Manages the current service provider, with getters for internal PackageConfig A scoped instance (see section below) of the current library's config BackgroundTaskExecutor Allow for async Qilletni callbacks, outlined in the Background Tasks page"},{"location":"native_binding/native_bind_factories/#adding-custom-injectable-classes","title":"Adding Custom Injectable Classes","text":"<p>Sometimes, you have your own factories or other classes that you want injected into classes with native methods. To do this, first you must implement the NativeFunctionBindingFactory class. Then, add it to the qilletni_info.yml file, such as:</p> qilletni_info.yml<pre><code># ...\nnative_bind_factory: dev.qilletni.lib.spotify.SpotifyNativeFunctionBindingFactory\n</code></pre> <p>The implementation of this interface may look something like this:</p> SpotifyNativeFunctionBindingFactory<pre><code>public class SpotifyNativeFunctionBindingFactory implements NativeFunctionBindingFactory {\n\n    @Override\n    public void applyNativeFunctionBindings(NativeFunctionClassInjector nativeFunctionClassInjector) {\n        nativeFunctionClassInjector.addInjectableInstance(new PlaylistCreator(SpotifyApiSingleton.getSpotifyAuthorizer()));\n    }\n}\n</code></pre> <p>This will now allow the spotify library's class, <code>PlaylistCreator</code> to be used in classes containing native methods, such as:</p> PlaylistToolsFunctions.java<pre><code>public class PlaylistToolsFunctions {\n    private final PlaylistCreator playlistCreator;\n\n    public PlaylistToolsFunctions(PlaylistCreator playlistCreator) {\n        this.playlistCreator = playlistCreator;\n    }\n}\n</code></pre>"},{"location":"native_binding/native_bind_factories/#scoped-injectable-classes","title":"Scoped Injectable Classes","text":"<p>Not all injectable instances may need to be injected into all classes. Qilletni offers the ability to scope the injectable classes via class name, allowing more restricted access to them. This also lets you have multiple native method classes taking in different instances of the same class or interface. Below is an example of setting a scoped injectable class, and two classes trying to use it.</p> CatNativeFunctionsBindingFactory.java<pre><code>public class CatNativeFunctionsBindingFactory implements NativeFunctionBindingFactory {\n\n    @Override\n    public void applyNativeFunctionBindings(NativeFunctionClassInjector nativeFunctionClassInjector) {\n        nativeFunctionClassInjector.addScopedInjectableInstance(new CatSitter(), List.of(CatFunctions.class));\n    }\n}\n</code></pre> CatFunctions.java<pre><code>public class CatFunctions {\n    private final CatSitter catSitter;\n\n    public CatFunctions(CatSitter catSitter) {  // Works\n        this.catSitter = catSitter;\n    }\n}\n</code></pre> LitterBoxFunctions.java<pre><code>public class LitterBoxFunctions {\n    private final CatSitter catSitter;\n\n    public LitterBoxFunctions(CatSitter catSitter) {  // Fails; Can't find injectable CatFunctions instance\n        this.catSitter = catSitter;\n    }\n}\n</code></pre>"},{"location":"native_binding/native_functions/","title":"Native Methods","text":"<p>Native methods in Qilletni are functions that are bound to a Java method. They are defined like a normal method signature, but with no body. For instance,</p> <pre><code>native fun getHostname()\n</code></pre> <p>This page will go over how to use these functions, how to implement them, etc.</p>"},{"location":"native_binding/native_functions/#setting-up-a-native-project","title":"Setting Up a Native Project","text":"<p>If you haven't created a project with native bindings, see the the Project Structure page for setting it up. In the <code>native_classes</code> section of your <code>qilletni_info.yml</code> file, ensure a Java class' canonical name is present. This should already be present in the project's template.</p> <p>The naming standard of files with native methods in them is <code>XyzFunctions</code>, such as <code>CatFunctions</code>. For example,</p> qilletni_info.yml<pre><code># ...\nnative_classes:\n  - dev.qilletni.lib.cats.CatFunctions\n</code></pre>"},{"location":"native_binding/native_functions/#creating-a-basic-function","title":"Creating a Basic Function","text":"<p>The following is a basic example of a function, in the class mentioned above.</p> cats.ql<pre><code>native fun getCatNames()\n\nstring[] names = getCatNames()\nprint(names)  // Prints \"[Olive, Johnny, Oyster]\"\n</code></pre> CatFunctions.java<pre><code>public class CatFunctions {\n    public List&lt;String&gt; getCatNames() {\n        return List.of(\"Olive\", \"Johnny\", \"Oyster\");\n    }\n}\n</code></pre> <p>Qilletni offers the ability to both automatically convert to/from certain types when methods are invoked, and also some manual conversions. The following Java method is what it would look like without automatic conversions.</p> CatFunctions.java<pre><code>public class CatFunctions {\n    private final ListAdapter listAdapter;\n\n    public CatFunctions(ListAdapter listAdapter/*(1)!*/) {\n        this.listAdapter = listAdapter;\n    }\n\n    public ListType getCatNames() {\n        var list = List.of(\"Olive\", \"Johnny\", \"Oyster\");\n        return listAdapter.createListFromJava(list);\n    }\n}\n</code></pre> <ol> <li>This type is automatically injected into the class when the method is invoked. See Native Bind Factories for other classes that may be injected.</li> </ol> <p>The following is a basic example of a function that takes in a parameter. For demonstration, they are mixed in both auto converted types and an unconverted type.</p> <pre><code>native fun findAvgAge(cat1, cat2)\n</code></pre> <pre><code>public int findAvgAge(int cat1, IntType cat2) {\n    int cat2Age = cat2.getValue();\n    return (cat1 + cat2Age) / 2;\n}\n</code></pre> <p>It is recommended to use automatic type conversion, but is not necessary. For a list of all automatic type conversions, see Automatic Type Conversion.</p>"},{"location":"native_binding/native_functions/#qilletni-type-structure","title":"Qilletni Type Structure","text":"<p>Native types in Qilletni are all subtypes of QilletniType. A method may both return or take in any QilletniType.</p>"},{"location":"native_binding/native_functions/#automatic-type-conversion","title":"Automatic Type Conversion","text":"<p>To assist with dealing with built-in Qilletni types, Qilletni will automatically convert certain types to their Java counterparts. They convert both in method parameters and in the return type. The following is a table with the built-in type converters. The reason why there are duplicates is when a parameter is passed in from Qilletni, it converts it from a QilletniType to a Java type. When a Java type is returned, it converts it to a QilletniType.</p> From To Notes BooleanType boolean boolean BooleanType IntType long long IntType IntType int int IntType DoubleType double double DoubleType StringType String String StringType ListType List Currently, items inside a list are not transformed to Java types List ListType A list must contain only the same type Map (Entity) HashMap Converts the std lib's Map to a HashMap Object JavaType If a native method returns an Object (any non-converted class), it will be given to Qilletni as a JavaType"},{"location":"native_binding/native_functions/#skipping-automatic-type-conversion","title":"Skipping Automatic Type Conversion","text":"<p>If a type is returned and you don't want it to automatically convert, such as returning a JavaType of HashMap without converting it to the Map entity, the @SkipReturnTypeAdapter annotation may be used on the method. The following is an example that is used in the Map entity itself, to initialize a Java type of HashMap.</p> MapFunctions.java<pre><code>@SkipReturnTypeAdapter\npublic static Object _emptyJavaMap() {\n    return new HashMap&lt;&gt;();\n}\n</code></pre>"},{"location":"native_binding/native_functions/#dealing-with-entities","title":"Dealing With Entities","text":"<p>Entities are a little more complicated to handle in native methods, as they are inherently more complex than the predefined types. Luckily, Qilletni has the full ability to manipulate them and make your own.</p> <p>When an entity instance is passed into a native method, it is passed in as an EntityType. To access the fields or functions in the entity, getEntityScope() can be used, as shown below.</p> cats.ql<pre><code>entity Cat {\n    string name\n    int age\n\n    Cat(name, age)\n}\n\nnative fun sayHello(cat)\n\nCat cat = new Cat(\"Beer\", 2)\nsayHello(cat)  // Prints \"Hello Beer, you are 2 years old!\"\n</code></pre> CatFunctions.java<pre><code>public class CatFunctions {\n    public void sayHello(EntityType catEntity) {\n        StringType stringType = catEntity.getEntityScope().&lt;StringType&gt;lookup(\"name\").getValue();\n        String name = stringType.getValue();\n\n        IntType intType = catEntity.getEntityScope().&lt;IntType&gt;lookup(\"age\").getValue();\n        long age = intType.getValue();\n\n        System.out.println(\"Hello %s, you are %d years old!\".formatted(name, age));\n    }\n}\n</code></pre> <p>The first getValue() call returns the value of the Symbol, which is an internal representation of a variable that may hold any Qilletni type. From there, the value from each is gotten which is the actual type instance. Note that IntTypes are internally represented as <code>long</code>s.</p> <p>If a variable is changed, the Symbol does not need to be re-set, but it can be. An example of a variable being updated is:</p> cats.ql<pre><code>native fun catBirthday(cat)\n\nCat cat = new Cat(\"Beer\", 2)\ncatBirthday(cat)\n\nprint(cat)  // Prints \"Cat(name = Beer, age = 3)\"\n</code></pre> CatFunctions.java<pre><code>public void catBirthday(EntityType catEntity) {\n    IntType age = catEntity.getEntityScope().&lt;IntType&gt;lookup(\"age\").getValue();\n    age.setValue(age.getValue() + 1);\n}\n</code></pre>"},{"location":"native_binding/native_functions/#entityrecord-conversion","title":"Entity/Record Conversion","text":"<p>Entities may also be automatically converted to and from Java records, using the TypeConverter class. The instance of this class is acquired through automatic injection, see Native Bind Factories for more information, and the other classes available to use. Below is an example of taking in an entity and automatically converting it to a record.</p> cats.ql<pre><code>entity Cat {\n    string name\n    int age\n\n    Cat(name, age)\n}\n\nnative fun sayHello(cat)\n\nCat cat = new Cat(\"Beer\", 2)\nsayHello(cat)  // Prints \"Hello Beer, you are 2 years old!\"\n</code></pre> CatFunctions.java<pre><code>public class CatFunctions {\n    private final TypeConverter typeConverter;\n\n    public CatFunctions(TypeConverter typeConverter) {\n        this.typeConverter = typeConverter;\n    }\n\n    private record Cat(String name, int age) {}\n\n    public void sayHello(EntityType catEntity) {\n        Cat cat = typeConverter.convertFromEntityToRecord(catEntity, Cat.class);\n        System.out.println(\"Hello %s, you are %d years old!\".formatted(cat.name(), cat.age()));\n    }\n}\n</code></pre> <p>The above code uses the convertFromEntityToRecord method to take an EntityType, and map its properties to a Java record that has fields of the same name.</p> <p>Similarly, the convertFromRecordToEntity method does the opposite, taking a Record and mapping it to an EntityType, matching its values up with the constructor of the entity, as shown below. This assumes the Cat entity is still defined.</p> cats.ql<pre><code>native fun createNewCat(name, age)\n\nCat cat = createNewCat(\"Martini\", 3)\nprint(cat)  // Prints \"Cat(name = Martini, age = 3)\"\n</code></pre> CatFunctions.java<pre><code>public EntityType createNewCat(String name, int age) {\n    Cat cat = new Cat(name, age);\n    return typeConverter.convertFromRecordToEntity(\"Cat\", cat);\n}\n</code></pre>"},{"location":"native_binding/native_functions/#native-entity-functions","title":"Native Entity Functions","text":"<p>Qilletni also supports native entity member functions. This is defined in Qilletni the same as a normal native method, just in the entity.</p> cats.ql<pre><code>entity Cat {\n    string name\n    int age\n\n    Cat(name, age)\n\n    native fun pet()\n}\n</code></pre> <p>Implementing this function in Java uses the @NativeOn annotation on the method. This takes in the entity name this is on (<code>on</code> in a similar context to an extension method's syntax).</p> CatFunctions.java<pre><code>@NativeOn(\"Cat\")\npublic void pet() {\n    StringType name = catEntity.getEntityScope().&lt;StringType&gt;lookup(\"name\").getValue();\n    System.out.println(\"Petting %s!\".formatted(name.getValue()));\n}\n</code></pre> <p>Often times a whole Java class is dedicated for native methods on an entity. The @NativeOn annotation may also be applied to a class definition, making all methods that line up with signatures native methods, as shown below.</p> CatFunctions.java<pre><code>@NativeOn(\"Cat\")\npublic class CatFunctions {\n    public void pet() {\n        StringType name = catEntity.getEntityScope().&lt;StringType&gt;lookup(\"name\").getValue();\n        System.out.println(\"Petting %s!\".formatted(name.getValue()));\n    }\n}\n</code></pre>"},{"location":"native_binding/native_functions/#injectable-types","title":"Injectable Types","text":"<p>Qilletni providers a set of classes that may be put in the constructor, and are populated when a native method is invoked. It also has the ability to inject your own classes to be used both by other libraries or scoped to just your own. See the Native Bind Factories page for more information on this.</p>"},{"location":"native_binding/native_functions/#preload-methods","title":"Preload Methods","text":"<p>Sometimes, especially in the case of when many methods are being performed on the same entity, a common action must happen before any of the methods get invoked. Executing code other than member variable setting is not recommended, so for this, the @BeforeAnyInvocation annotation may be used on a single method in the class, which will be invoked before the body of any native method is ran. This method takes one parameter, which is the EntityType the method is being invoked on. This may set up instance variables (as there is one instance of the class for every call) or do anything else necessary. The example below is from the standard library std-lib, ensuring the song is populated with service provider data before an invocation is made on it.</p> SongFunctions.java<pre><code>@NativeOn(\"song\")\npublic class SongFunctions {\n    private final MusicPopulator musicPopulator;\n\n    public SongFunctions(MusicPopulator musicPopulator) {\n        this.musicPopulator = musicPopulator;\n    }\n\n    @BeforeAnyInvocation\n    public void setupSong(SongType songType) {\n        musicPopulator.populateSong(songType);\n    }\n\n    public String getTitle(SongType songType) { // (1)!\n        return songType.getTrack().getName();\n    }\n}\n</code></pre> <ol> <li>If the <code>@BeforeAnyInvocation</code> method wasn't ran and the song hadn't been loaded yet, getTrack() would be null.</li> </ol>"},{"location":"quickstart/getting_started/","title":"Getting Started with Qilletni","text":"<p>Welcome to Qilletni, a Domain-Specific Language (DSL) designed for advanced playlist management, music curation, and seamless integration with Spotify and Java libraries.</p>"},{"location":"quickstart/getting_started/#introduction","title":"Introduction","text":"<p>Qilletni simplifies the creation and manipulation of playlists and music data, allowing you to automate tasks, integrate with external libraries, and leverage a rich standard library. If you\u2019d like a broader overview of Qilletni, see the Home page for more details.</p>"},{"location":"quickstart/getting_started/#installation","title":"Installation","text":""},{"location":"quickstart/getting_started/#start-database","title":"Start Database","text":"<p>Qilletni leverages a database for caching music data for efficient lookups and conversions. The easiest way to start a caching database is via docker, using a command such as:</p> <pre><code>docker run -d \\\n  --name qilletni-db \\\n  -p 5435:5432 \\\n  -e POSTGRES_USER=qilletni \\\n  -e POSTGRES_PASSWORD=pass \\\n  -e POSTGRES_DB=qilletni \\\n  -v ~/.qilletni/cache:/var/lib/postgresql/data \\\n  postgres\n</code></pre>"},{"location":"quickstart/getting_started/#install-qilletni","title":"Install Qilletni","text":"<p>There are two ways to use Qilletni. You may install it on your system, or use the Docker image. A normal system install is recommended (everything is put under <code>~/.qilletni</code>), but a Docker install is great for trying things out.</p>"},{"location":"quickstart/getting_started/#install-on-system","title":"Install on System","text":"<p>For a system install, first install you have at least Java 22 installed. To install Qilletni, run the following in a bash shell:</p> <pre><code>curl https://raw.githubusercontent.com/RubbaBoy/QilletniToolchain/refs/heads/master/scripts/install.sh | bash\n</code></pre> <p>Then, open a new shell or run <code>source ~/.bashrc</code></p> <p>From there, you can run <code>qilletni --help</code> for a list of commands.</p>"},{"location":"quickstart/getting_started/#use-with-docker","title":"Use with Docker","text":"<p>To use with Docker, run the following:</p> <pre><code>docker run --rm \\\n  --network host \\\n  -v qilletni-docker-run:/root \\\n  -v \"/$(pwd)\":/data \\\n  ghcr.io/rubbaboy/qilletni:latest \\\n  --help\n</code></pre> <p>Which is equivalent to running <code>qilletni --help</code></p> <p>To run a file, it's recommended to <code>cd</code> into the parent directory of the file and run it from there. For example, to run <code>/e/qilletni/demo.ql</code> you would do, from the <code>/e/qilletni</code> directory,</p> <pre><code>docker run --rm \\\n  --network host \\\n  -v qilletni-docker-run:/root \\\n  -v \"/$(pwd)\":/data \\\n  ghcr.io/rubbaboy/qilletni:latest \\\n  run demo.ql\n</code></pre>"},{"location":"quickstart/getting_started/#hello-world-your-first-program","title":"Hello World (Your First Program)","text":"<p>Let\u2019s create a simple \"Hello, World!\" program:</p> <ol> <li>Initialize a project Create a project directory, and then run the command</li> </ol> <pre><code>qilletni init qilletni_demo/\n</code></pre> <p>It will ask you for a project name, and the author's name. In this case, we'll give it the name <code>qilletni_demo</code>. It will also ask for an optional native binding class name, which may be left blank for now.</p> <p>This will create a file tree of the following structure:</p> <pre><code>qilletni_demo/\n\u2514\u2500\u2500 qilletni-src/\n    \u251c\u2500\u2500 qilletni_demo.ql\n    \u2514\u2500\u2500 qilletni_info.yml\n</code></pre> <p>The file created, <code>qilletni_demo.ql</code>, is the start of your source code. Right now, it only contains:</p> qilletni_demo.ql<pre><code>print(\"Hello, World!\")\n</code></pre> <p>A more in-depth explanation of the project structure, and other project types, can be found in the Project Structure guide.</p> <ol> <li>Run the program via command line:</li> </ol> <pre><code>qilletni run qilletni-src/qilletni_demo.ql\n</code></pre> <p>If everything is set up correctly, you should see:</p> <pre><code>Hello, World!\n</code></pre>"},{"location":"quickstart/getting_started/#next-steps","title":"Next Steps","text":"<p>Now that you have a Qilletni program running, it's time to link a music service. Check out the Spotify or Last.Fm pages for more info. If you've done that, feel tree to check out the Language Introduction or some of the official packages.</p>"},{"location":"quickstart/lastfm_integration/","title":"Last.Fm Integration","text":"<p>Last.Fm integration is provided via the lastfm package, which is a Service Provider. Because it is a standalone package, it must be connected to Last.Fm.</p>"},{"location":"quickstart/lastfm_integration/#api-setup","title":"API Setup","text":"<p>Because using Qilletni is essentially using an API and not an end application, you must create Last.Fm API keys for your account.</p> <p>To create an API, sign into https://www.last.fm/api/account/create and fill out the information, and click Submit. The Callback URL is not required.</p> <p>From there, copy the API Key and Shared Secret, and run the following <code>qilletni</code> command in your console:</p> <pre><code>qilletni persist lastfm apiKey=api-key apiSecret=api-secret\n</code></pre> <p>Where <code>api-key</code> is your API Key, such as <code>f8ea7243239ec13d1ab6b858532c5b32</code>, and <code>api-secret</code> is your Shared Secret, such as <code>7f713e749d63adeab805ed78c9585f11</code>.</p>"},{"location":"quickstart/lastfm_integration/#database-setup","title":"Database Setup","text":"<p>The Last.Fm package also needs database access for caching music data. If using the default Docker Postgres settings from Getting Started, the following settings are populated by default and do not need manual setting:</p> <pre><code>| Property     | Value                                             |\n| ------------ | ------------------------------------------------- |\n| dbUsername   | qilletni                                          |\n| dbUrl        | jdbc:postgresql://localhost:5435/qilletni_lastfm  |\n| dbPassword   | pass                                              |\n</code></pre> <p>To set these manually, the following may be ran:</p> <pre><code>qilletni persist lastfm dbUsername=.. dbUrl=.. dbPassword=..\n</code></pre>"},{"location":"quickstart/lastfm_integration/#using-the-package","title":"Using The Package","text":"<p>The following is a quick example of a Qilletni program. Follow the Getting Started guide to create a project, and add the following dependency in your <code>qilletni_info.yml</code> file:</p> qilletni_info.yml<pre><code>dependencies:\n  - lastfm:^1.0.0\n</code></pre> <p>And make a basic program, which checks the most recent 50 songs played on your account:</p> qilletni_demo.ql<pre><code>import \"lastfm:lastfm.ql\"\n\nLastFmResult result = getRecentTracks(\"RubbaBoy\")\n\nif (result.isError()) {\n    printf(\"Error: %s\", [result.errorMessage])\n    exit(1)\n}\n\nprintf(\"Recent Tracks:\\n\\t%s\", [result.data])\n</code></pre> <p>Which should output something similar to:</p> <pre><code>Recent Tracks:\n        [song(\"Euclid\" by \"Sleep Token\"), song(\"Take Me Back to Eden\" by \"Sleep Token\"), ...]\n</code></pre> <p>For more usage of the Last.Fm package, see the Last.Fm Package Page.</p>"},{"location":"quickstart/spotify_integration/","title":"Spotify Integration","text":"<p>Spotify integration is provided via the spotify package, which is a Service Provider. Because it is a standalone package, it must be connected to Spotify.</p>"},{"location":"quickstart/spotify_integration/#api-setup","title":"API Setup","text":"<p>Because using Qilletni is essentially using an API and not an end application, you must create Spotify API keys for your account.</p> <p>To create an API, sign into https://developer.spotify.com/dashboard and click <code>Create app</code> and fill in the <code>App name</code> and <code>App description</code>. Set the <code>Redirect URIs</code> field to <code>http://localhost:8088/spotify</code> and create the app.</p> <p>Copy the Client ID from the Basic Information tab, and run the following <code>qilletni</code> command in your console:</p> <pre><code>qilletni persist spotify redirectUri=http://localhost:8088/spotify clientId=client-id\n</code></pre> <p>Where <code>client-id</code> is your Client ID, such as <code>c92e7a91a4d1402bca2e26a9e25e2be6</code>.</p>"},{"location":"quickstart/spotify_integration/#database-setup","title":"Database Setup","text":"<p>The Spotify package also needs database access for caching music data. If using the default Docker Postgres settings from Getting Started, the following settings are populated by default and do not need manual setting:</p> <pre><code>| Property     | Value                                              |\n| ------------ | -------------------------------------------------- |\n| dbUsername   | qilletni                                           |\n| dbUrl        | jdbc:postgresql://localhost:5435/qilletni_spotify  |\n| dbPassword   | pass                                               |\n</code></pre> <p>To set these manually, the following may be ran:</p> <pre><code>qilletni persist spotify dbUsername=.. dbUrl=.. dbPassword=..\n</code></pre>"},{"location":"quickstart/spotify_integration/#using-the-package","title":"Using The Package","text":"<p>The following is a quick example of a Qilletni program. Follow the Getting Started guide to create a project, and add the following dependency in your <code>qilletni_info.yml</code> file:</p> qilletni_info.yml<pre><code>dependencies:\n  - spotify:^1.0.0\n</code></pre> <p>And make a basic program, which adds a song to your Spotify account's queue:</p> qilletni_demo.ql<pre><code>play \"Fireflies\" by \"Owl City\"\n</code></pre> <p>For more usage of the Spotify package, see the Spotify Package Page.</p>"}]}